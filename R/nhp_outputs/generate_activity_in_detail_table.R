# Activity in detail ----

#' Generate Activity in Detail Table
#' @param data List. Contents of the JSON generated by the inputs app.
#' @param sites Character. Location codes selected by the user from the outputs
#'     app interface.
#' @param tretspefs Data.frame. Treatment specialties lookup of codes to
#'     descriptions. Derived from internal JSON lookup.
#' @param activity_type Character. The activity type (e.g. 'ip' for inpatients).
#' @param pod Character. The point of delivery (e.g.
#'     'ip_non-elective_admission').
#' @param measure Character. A selected measure (e.g. 'beddays').
#' @param agg_col Character. Name of column to aggregate by (i.e. age,
#'     'age_group', or treatment specialty, 'tretspef').
#' @noRd
generate_activity_in_detail_table <- function(
    data,
    sites,
    tretspefs,
    activity_type,
    pod,
    measure,
    agg_col
) {
  aggregated_data <- data |>
    get_aggregation(pod, measure, agg_col, sites)
  
  
  # if a site is selected then there are no rows for A&E
  if (nrow(aggregated_data) == 0) {
    stop("No data")
  }
  
  
  aggregated_data <- aggregated_data |>
    dplyr::transmute(
      .data$sex,
      agg = .data[[agg_col]],
      .data$baseline,
      final = .data$principal,
      change = .data$final - .data$baseline,
      change_pcnt = .data$change / .data$baseline
    )
  
  
  if (agg_col == "tretspef") {
    aggregated_data <- aggregated_data |>
      dplyr::left_join(
        tretspefs,
        by = dplyr::join_by("agg" == "Code")
      ) |>
      dplyr::mutate(
        dplyr::across(
          "Description",
          \(x) dplyr::if_else(is.na(x), .data$agg, .data$Description)
        ),
      ) |>
      dplyr::select("sex", "Description", dplyr::everything(), -"agg") |>
      dplyr::rename("agg" = "Description")
  }
  
  
  end_year <- data[["params"]][["end_year"]]
  end_fyear <- paste0(
    end_year,
    "/",
    as.numeric(stringr::str_extract(end_year, "\\d{2}$")) + 1
  )
  
  
  aggregated_data |>
    mod_principal_detailed_table(
      aggregation = agg_col,
      final_year = end_fyear
    ) |>
    gt::tab_options(table.align = "left")
}


activity_detail_bar <- function(data, chosen_sex, title_text = "Example", ylab = "ylab", xlab = "xlab"){
  ggplot(filter(data, sex== chosen_sex),
         aes(x=final, y=fct_rev(agg), fill = scenario)) +
    geom_col(position = "dodge") +
    scale_x_continuous(labels = scales::comma) +
    ggtitle(title_text) +
    ylab(ylab) +
    xlab(xlab) +
    scale_fill_manual(values = c("#f9bf07","#686f73"), name="Scenario", labels = c(scenario_1_name, scenario_2_name)) +
    easy_center_title() + theme(text = element_text(family = "Segoe UI")) +
    theme(axis.text.x = element_text(family = "Segoe UI", size = 12, color="black")) +
    theme(axis.text.y = element_text(family = "Segoe UI", size = 12, color="black")) +
    theme(axis.title.x = element_text(family = "Segoe UI", size = 12, color="black")) +
    theme(axis.title.y = element_text(family = "Segoe UI", size = 12, color="black")) +
    theme(legend.title = element_text(family = "Segoe UI", size = 12, color="black")) +
    theme(legend.text = element_text(family = "Segoe UI", size = 12, color="black"))
}


combine_activity_data <- function(data1, data2, tretspefs, activity_type, pod, measure, agg_col) {
  dplyr::bind_rows(
    scenario_1 = generate_activity_in_detail_table(
      data = data1,
      sites = NULL,
      tretspefs = tretspefs,
      activity_type = activity_type,
      pod = pod,
      measure = measure,
      agg_col = agg_col
      ),
    scenario_2 = generate_activity_in_detail_table(
      data = data2,
      sites = NULL,
      tretspefs = tretspefs,
      activity_type = activity_type,
      pod = pod,
      measure = measure,
      agg_col = agg_col
      ),
    .id = "scenario"
  )
}

# Function to generate names based on combinations of parameters
generate_name <- function(pod, measure, agg_col) {
  paste(pod, measure, agg_col, sep = "_")
}

# Function to apply `combine_activity_data` over all combinations and store results as a named list
run_combinations_list <- function(parameters, data1, data2) {
  results <- pmap(
    parameters, 
    ~ combine_activity_data(
      data1 = data1,
      data2 = data2,
      tretspefs = tretspef_lookup,
      activity_type = ..1,
      pod = ..2,
      measure = ..3,
      agg_col = ..4
    )
  )
  
  # Set names based on the combinations
  names(results) <- pmap_chr(select(parameters, pod, measure, agg_col), generate_name)
  
  return(results)
}
